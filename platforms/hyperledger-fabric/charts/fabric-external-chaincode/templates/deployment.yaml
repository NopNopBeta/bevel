##############################################################################################
#  Copyright Accenture. All Rights Reserved.
#
#  SPDX-License-Identifier: Apache-2.0
##############################################################################################
{{- if empty .Values.address }}
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Release.Name }}
  namespace: {{ .Release.Namespace }}
  labels:
    name: {{ .Release.Name }}
    app.kubernetes.io/name: {{ .Release.Name }}
    app.kubernetes.io/component: fabric
    app.kubernetes.io/part-of: {{ template "fabric-external-chaincode.fullname" . }}
    app.kubernetes.io/namespace: {{ .Release.Namespace }}
    app.kubernetes.io/release: {{ .Release.Name }}
    app.kubernetes.io/managed-by: helm
    {{- include "labels.deployment" . | nindent 4 }}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: {{ .Release.Name }}
      app.kubernetes.io/name: {{ .Release.Name }}
      app.kubernetes.io/component: fabric
      app.kubernetes.io/part-of: {{ template "fabric-external-chaincode.fullname" . }}
      app.kubernetes.io/namespace: {{ .Release.Namespace }}
      app.kubernetes.io/release: {{ .Release.Name }}
      app.kubernetes.io/managed-by: helm
  template:
    metadata:
      labels:
        app: {{ .Release.Name }}
        app.kubernetes.io/name: {{ .Release.Name }}
        app.kubernetes.io/component: fabric
        app.kubernetes.io/part-of: {{ template "fabric-external-chaincode.fullname" . }}
        app.kubernetes.io/namespace: {{ .Release.Namespace }}
        app.kubernetes.io/release: {{ .Release.Name }}
        app.kubernetes.io/managed-by: helm
        {{- include "labels.deployment" . | nindent 8 }}
    spec:   
      serviceAccountName: {{ .Values.global.serviceAccountName }}
      {{- if .Values.image.pullSecret }}
      imagePullSecrets:
        - name: {{ .Values.image.pullSecret }}
      {{- end }}
      volumes:
      {{- if .Values.global.vault.tls }}
      - name: vaultca
        secret:
          secretName: {{ .Values.global.vault.tls }}
          items:
          - key: ca.crt.pem
            path: ca-certificates.crt
      {{- end }}
      - name: certificates
        emptyDir:
          medium: Memory
      - name: scripts-volume
        configMap:
          name: bevel-vault-script
      - name: package-manager
        configMap:
          name: package-manager
      initContainers:
      {{- if .Values.chaincode.tls }}
      # Init container to retrieve TLS certificates for chaincode server
      - name: certificates-init
        image: {{ .Values.image.alpineutils }}
        imagePullPolicy: IfNotPresent
        env:
        - name: CHAINCODE_NAME
          value: "{{ .Values.chaincode.name }}"
        - name: CHAINCODE_VERSION
          value: "{{ .Values.chaincode.version }}"
        - name: COMPONENT_NAME
          value: "{{ .Release.Namespace }}"
        {{- if eq .Values.global.vault.type "hashicorp" }}
        - name: VAULT_ADDR
          value: {{ .Values.global.vault.address }}
        - name: VAULT_SECRET_ENGINE
          value: "{{ .Values.global.vault.secretEngine }}"
        - name: VAULT_SECRET_PREFIX
          value: "{{ .Values.global.vault.secretPrefix }}"
        - name: KUBERNETES_AUTH_PATH
          value: {{ .Values.global.vault.authPath }}
        - name: VAULT_APP_ROLE
          value: {{ .Values.global.vault.role }}
        - name: VAULT_TYPE
          value: "{{ .Values.global.vault.type }}"
        {{- if .Values.global.vault.tls }}
        - name: VAULT_CACERT
          value: /opt/vault/tls/ca-certificates.crt
        {{- else }}
        - name: VAULT_SKIP_VERIFY
          value: "true"
        {{- end }}
        {{- end }}
        - name: MOUNT_PATH
          value: /secret
        command: ["sh", "-c"]
        args:
        - |-
          #!/usr/bin/env sh
          set -e
          
          {{- if eq .Values.global.vault.type "hashicorp" }}
          . /scripts/bevel-vault.sh
          vaultBevelFunc "init"
          
          function getChaincodeTlsSecret {
            SERVER_USER="${CHAINCODE_NAME}-${CHAINCODE_VERSION}"
            TLS_KEY="${SERVER_USER}-tls"
            
            echo "Getting chaincode server TLS certificates from Vault for ${TLS_KEY}"
            vaultBevelFunc "readJson" "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/chaincodes/${TLS_KEY}"
            if [ "$SECRETS_AVAILABLE" == "yes" ]
            then
              CA_CERT=$(echo ${VAULT_SECRET} | jq -r '.["ca_crt"]')
              CLIENT_CERT=$(echo ${VAULT_SECRET} | jq -r '.["client_crt"]')
              CLIENT_KEY=$(echo ${VAULT_SECRET} | jq -r '.["client_key"]')

              echo "${CA_CERT}" | base64 -d > ${MOUNT_PATH}/ca.crt
              echo "${CLIENT_CERT}" | base64 -d > ${MOUNT_PATH}/client.crt
              echo "${CLIENT_KEY}" | base64 -d > ${MOUNT_PATH}/client.key
              CC_TLS_SECRET=true
            else
              CC_TLS_SECRET=false
            fi
          }
          {{- else }}
          function getChaincodeTlsSecret {
            SERVER_USER="${CHAINCODE_NAME}-${CHAINCODE_VERSION}"
            TLS_KEY="${SERVER_USER}-tls"
            
            echo "Getting chaincode server TLS certificates from Kubernetes secret ${TLS_KEY}"
            if kubectl get secret ${TLS_KEY} --namespace {{ .Release.Namespace }} >/dev/null 2>&1; then
              TLS_CA_CERT=$(kubectl get secret ${TLS_KEY} --namespace {{ .Release.Namespace }} -o jsonpath='{.data.cacrt}' | base64 -d)
              TLS_CLIENT_CERT=$(kubectl get secret ${TLS_KEY} --namespace {{ .Release.Namespace }} -o jsonpath='{.data.clientcrt}' | base64 -d)
              TLS_CLIENT_KEY=$(kubectl get secret ${TLS_KEY} --namespace {{ .Release.Namespace }} -o jsonpath='{.data.clientkey}' | base64 -d)
              
              echo "${TLS_CA_CERT}" > ${MOUNT_PATH}/ca.crt
              echo "${TLS_CLIENT_CERT}" > ${MOUNT_PATH}/client.crt
              echo "${TLS_CLIENT_KEY}" > ${MOUNT_PATH}/client.key
              CC_TLS_SECRET=true
            else
              CC_TLS_SECRET=false
            fi
          }
          {{- end }}
          
          COUNTER=1
          while [ "$COUNTER" -le {{ .Values.chaincode.healthCheck.retries | default 5 }} ]
          do
            mkdir -p ${MOUNT_PATH}
            getChaincodeTlsSecret

            if [ "$CC_TLS_SECRET" = "true" ]
            then
              echo "Chaincode server TLS certificates have been obtained correctly"
              break
            else
              echo "Chaincode server TLS certificates have not been obtained, sleeping for {{ .Values.chaincode.healthCheck.sleepTimeAfterError | default 30 }}"
              sleep {{ .Values.chaincode.healthCheck.sleepTimeAfterError | default 30 }}
              COUNTER=`expr "$COUNTER" + 1`
            fi
          done

          if [ "$COUNTER" -gt {{ .Values.chaincode.healthCheck.retries | default 5 }} ]
          then
            echo "Retry attempted `expr $COUNTER - 1` times, The chaincode server TLS certificates have not been obtained."
            exit 1
          fi
        volumeMounts:
        {{- if .Values.global.vault.tls }}
        - name: vaultca
          mountPath: "/etc/ssl/certs/"
          readOnly: true
        {{- end }}
        - name: certificates
          mountPath: /secret
        - name: scripts-volume
          mountPath: /scripts/bevel-vault.sh
          subPath: bevel-vault.sh
      {{- end }}
      
      containers:
        - name: chaincode
          image: {{ .Values.image.external_chaincode }}
          imagePullPolicy: Always
          env:
            - name: CHAINCODE_ID
              valueFrom:
                secretKeyRef:
                  name: "{{ .Values.chaincode.name }}-{{ .Values.chaincode.version }}-package-id"
                  key: package_id
            - name: CHAINCODE_SERVER_ADDRESS
              value: "0.0.0.0:7052"
            - name: CHAINCODE_TLS_DISABLED
              value: "{{ not .Values.chaincode.tls }}"
            {{- if .Values.chaincode.tls }}
            - name: CORE_CHAINCODE_TLS_KEY_FILE
              value: "{{ .Values.chaincode.crypto_mount_path | default "/crypto" }}/client.key"
            - name: CORE_CHAINCODE_TLS_CERT_FILE
              value: "{{ .Values.chaincode.crypto_mount_path | default "/crypto" }}/client.crt"
            - name: CORE_CHAINCODE_TLS_CLIENT_CACERT_FILE
              value: "{{ .Values.chaincode.crypto_mount_path | default "/crypto" }}/ca.crt"
            {{- end }}
          ports:
            - containerPort: 7052
          {{- if .Values.chaincode.tls }}
          volumeMounts:
          - name: certificates
            mountPath: {{ .Values.chaincode.crypto_mount_path | default "/crypto" }}
            readOnly: true
          {{- end }}
{{- end }}
