apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Release.Name }}-package-install
  labels:
    app.kubernetes.io/name: {{ include "fabric-external-chaincode.name" . }}-package
    app.kubernetes.io/component: chaincode-package
    app.kubernetes.io/part-of: {{ include "fabric-external-chaincode.fullname" . }}
    app.kubernetes.io/namespace: {{ .Release.Namespace }}
    app.kubernetes.io/release: {{ .Release.Name }}
    app.kubernetes.io/managed-by: helm
  annotations:
    helm.sh/hook-weight: "1"
    helm.sh/hook: "pre-install,pre-upgrade"
    helm.sh/hook-delete-policy: "before-hook-creation"
    helm.sh/hook-depends-on: "{{ .Release.Name }}-certs"
spec:
  backoffLimit: 5
  completions: 1
  template:
    metadata:
      labels:
        app.kubernetes.io/name: {{ include "fabric-external-chaincode.name" . }}-package
        app.kubernetes.io/component: chaincode-package
        app.kubernetes.io/part-of: {{ include "fabric-external-chaincode.fullname" . }}
        app.kubernetes.io/namespace: {{ .Release.Namespace }}
        app.kubernetes.io/release: {{ .Release.Name }}
        app.kubernetes.io/managed-by: helm
    spec:
      serviceAccountName: {{ .Values.global.serviceAccountName }}
      restartPolicy: "OnFailure"
      {{- if .Values.image.pullSecret }}
      imagePullSecrets:
        - name: {{ .Values.image.pullSecret }}
      {{- end }}
      volumes:
      - name: certificates
        emptyDir:
          medium: Memory
      - name: package-temp
        emptyDir:
          medium: Memory
      - name: scripts-volume
        configMap:
          name: bevel-vault-script
      - name: package-manager
        configMap:
          name: package-manager
      {{- if .Values.global.vault.tls }}
      - name: vaultca
        secret:
          secretName: {{ .Values.global.vault.tls }}
          items:
          - key: ca-certificates.crt
            path: ca-certificates.crt
      {{- end }}
      containers:
        - name: package-chaincode
          image: {{ .Values.image.fabrictools }}
          imagePullPolicy: IfNotPresent
          env:
          - name: CHAINCODE_NAME
            value: "{{ .Values.chaincode.name }}"
          - name: CHAINCODE_VERSION
            value: "{{ .Values.chaincode.version }}"
          - name: CHAINCODE_TLS_ENABLED
            value: "{{ .Values.chaincode.tls | default false }}"
          - name: CHAINCODE_ADDRESS
            value: "{{ .Values.chaincode.address | default (printf "%s.%s.svc.cluster.local:7052" .Release.Name .Release.Namespace) }}"
          - name: PEER_NAME
            value: "{{ .Values.peer.name }}"
          - name: PEER_ADDRESS
            value: "{{ .Values.peer.address }}"
          - name: PEER_LOCALMSPID
            value: "{{ .Values.peer.localmspid }}"
          - name: PEER_TLS_ENABLED
            value: "{{ .Values.peer.tlsstatus }}"
          - name: COMPONENT_NAME
            value: "{{ .Release.Namespace }}"
          - name: ORG_NAME
            value: "{{ .Values.peer.localmspid | lower | replace "msp" "" }}"
          - name: FABRIC_LOGGING_SPEC
            value: "{{ .Values.peer.loglevel | default "info" }}"
          - name: CORE_PEER_TLS_ENABLED
            value: "{{ .Values.peer.tlsstatus }}"
          - name: CORE_PEER_LOCALMSPID
            value: "{{ .Values.peer.localmspid }}"
          - name: CORE_PEER_TLS_ROOTCERT_FILE
            value: "/opt/gopath/src/github.com/hyperledger/fabric/crypto/admin/msp/cacerts/ca.crt"
          - name: CORE_PEER_MSPCONFIGPATH
            value: "/opt/gopath/src/github.com/hyperledger/fabric/crypto/admin/msp"
          - name: CORE_PEER_ADDRESS
            value: "{{ .Values.peer.address }}"
          - name: ORDERER_CA
            value: "/opt/gopath/src/github.com/hyperledger/fabric/crypto/orderer/tls/ca.crt"
          {{- if eq .Values.global.vault.type "hashicorp" }}
          - name: VAULT_ADDR
            value: {{ .Values.global.vault.address }}
          - name: VAULT_APP_ROLE
            value: {{ .Values.global.vault.role }}
          - name: KUBERNETES_AUTH_PATH
            value: {{ .Values.global.vault.authPath }}
          - name: VAULT_TYPE
            value: {{ .Values.global.vault.type }}
          - name: VAULT_SECRET_ENGINE
            value: "{{ .Values.global.vault.secretEngine }}"
          - name: VAULT_SECRET_PREFIX
            value: "{{ .Values.global.vault.secretPrefix }}"
          {{- if .Values.global.vault.tls }}
          - name: VAULT_CACERT
            value: /opt/vault/tls/ca-certificates.crt
          {{- else }}
          - name: VAULT_SKIP_VERIFY
            value: "true"
          {{- end }}
          {{- end }}
          command: ["sh", "-c"]
          args:
            - |
              set -euo pipefail
              
              # Install required packages
              . /scripts/package-manager.sh
              packages_to_install="curl jq"
              install_packages "$packages_to_install"
              
              # Download kubectl binary
              curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.27.0/bin/linux/amd64/kubectl
              chmod u+x kubectl && mv kubectl /usr/local/bin/kubectl
              
              {{- if eq .Values.global.vault.type "hashicorp" }}
              # Initialize vault
              . /scripts/bevel-vault.sh
              echo "Getting vault Token..."
              vaultBevelFunc "init"
              {{- end }}
              
              echo "Starting chaincode package and installation process..."
              
              # Create package directory
              PACKAGE_DIR="/package-temp"
              mkdir -p ${PACKAGE_DIR}
              
              # Check if external chaincode package already exists
              PACKAGE_NAME="${CHAINCODE_NAME}_${CHAINCODE_VERSION}"
              echo "Checking if package ${PACKAGE_NAME} already exists..."
              
              {{- if eq .Values.global.vault.type "hashicorp" }}
              # Check vault for existing package
              PACKAGE_EXISTS="false"
              vaultBevelFunc 'readJson' "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/chaincodes/${CHAINCODE_NAME}/package/v${CHAINCODE_VERSION}"
              if [ "$SECRETS_AVAILABLE" = "yes" ]; then
                echo "Package already exists in vault"
                PACKAGE_EXISTS="true"
              fi
              {{- else }}
              # Check Kubernetes secret for existing package
              PACKAGE_EXISTS="false"
              if kubectl get secret --namespace {{ .Release.Namespace }} ${PACKAGE_NAME}-package >/dev/null 2>&1; then
                echo "Package already exists in Kubernetes secret"
                PACKAGE_EXISTS="true"
              fi
              {{- end }}
              
              if [ "$PACKAGE_EXISTS" = "false" ]; then
                echo "Creating new chaincode package..."
                
                # Wait for certificates to be generated if TLS is enabled
                {{- if .Values.chaincode.tls }}
                echo "TLS enabled - waiting for certificates to be generated..."
                
                # Wait for server certificates (for chaincode server identity)
                echo "Waiting for server certificates..."
                RETRY_COUNT=0
                MAX_RETRIES=30
                while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                  if [ -f /crypto-config/${CHAINCODE_NAME}-${CHAINCODE_VERSION}-certs-generated ]; then
                    echo "Server certificates found!"
                    break
                  fi
                  echo "Waiting for server certificates... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
                  sleep 10
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                done
                
                if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                  echo "Error: Timeout waiting for server certificates"
                  exit 1
                fi
                
                echo "Retrieving chaincode server certificates for TLS configuration..."
                
                {{- if eq .Values.global.vault.type "hashicorp" }}
                # Get server certificates from vault
                SERVER_USER="${CHAINCODE_NAME}-${CHAINCODE_VERSION}@{{ .Release.Namespace }}"
                vaultBevelFunc 'readJson' "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/chaincodes/${SERVER_USER}-tls"
                if [ "$SECRETS_AVAILABLE" = "yes" ]; then
                  echo "${VAULT_SECRET}" | jq -r ".ca_crt" | sed 's/\\n/\n/g' > ${PACKAGE_DIR}/ca.crt
                  echo "${VAULT_SECRET}" | jq -r ".client_crt" | sed 's/\\n/\n/g' > ${PACKAGE_DIR}/client.crt
                  echo "${VAULT_SECRET}" | jq -r ".client_key" | sed 's/\\n/\n/g' > ${PACKAGE_DIR}/client.key
                else
                  echo "Error: Server certificates not found in vault"
                  exit 1
                fi
                {{- else }}
                # Get server certificates from Kubernetes secret
                SERVER_USER="${CHAINCODE_NAME}-${CHAINCODE_VERSION}@{{ .Release.Namespace }}"
                kubectl get secret --namespace {{ .Release.Namespace }} ${SERVER_USER}-tls -o jsonpath='{.data.cacrt}' | base64 -d > ${PACKAGE_DIR}/ca.crt
                kubectl get secret --namespace {{ .Release.Namespace }} ${SERVER_USER}-tls -o jsonpath='{.data.clientcrt}' | base64 -d > ${PACKAGE_DIR}/client.crt
                kubectl get secret --namespace {{ .Release.Namespace }} ${SERVER_USER}-tls -o jsonpath='{.data.clientkey}' | base64 -d > ${PACKAGE_DIR}/client.key
                {{- end }}
                
                # Verify certificate files
                if [ ! -f ${PACKAGE_DIR}/ca.crt ] || [ ! -f ${PACKAGE_DIR}/client.crt ] || [ ! -f ${PACKAGE_DIR}/client.key ]; then
                  echo "Error: Certificate files are missing"
                  exit 1
                fi
                
                # Create connection.json with TLS
                echo "Creating connection.json with TLS configuration..."
                cd ${PACKAGE_DIR}
                jq -n \
                  --arg address "${CHAINCODE_ADDRESS}" \
                  --arg client_key "$(cat client.key)" \
                  --arg client_cert "$(cat client.crt)" \
                  --arg root_cert "$(cat ca.crt)" \
                  '{
                    "address": $address,
                    "dial_timeout": "10s",
                    "tls_required": true,
                    "client_auth_required": true,
                    "client_key": $client_key,
                    "client_cert": $client_cert,
                    "root_cert": $root_cert
                  }' > connection.json
                {{- else }}
                # Create connection.json without TLS
                echo "TLS disabled - Creating connection.json without TLS..."
                cd ${PACKAGE_DIR}
                jq -n \
                  --arg address "${CHAINCODE_ADDRESS}" \
                  '{
                    "address": $address,
                    "dial_timeout": "10s",
                    "tls_required": false,
                    "client_auth_required": false,
                    "client_key": "",
                    "client_cert": "",
                    "root_cert": ""
                  }' > connection.json
                {{- end }}
                
                # Create metadata.json
                echo "Creating metadata.json..."
                echo "{\"path\":\"\",\"type\":\"external\",\"label\":\"${PACKAGE_NAME}\"}" > metadata.json
                
                # Package the chaincode
                echo "Packaging chaincode..."
                tar cfz code.tar.gz connection.json
                tar cfz ${PACKAGE_NAME}.tgz code.tar.gz metadata.json
                
                # Verify package was created
                if [ ! -f "${PACKAGE_NAME}.tgz" ]; then
                  echo "Error: Package file was not created"
                  exit 1
                fi
                
                echo "Package created successfully: ${PACKAGE_NAME}.tgz"
                
                # Store package in vault or Kubernetes secret
                {{- if eq .Values.global.vault.type "hashicorp" }}
                echo "Storing package in vault..."
                PACKAGE_VAULT_ADDR="${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/chaincodes/${CHAINCODE_NAME}/package/v${CHAINCODE_VERSION}"
                PACKAGE_B64=$(cat ${PACKAGE_NAME}.tgz | base64 -w 0)
                echo "{\"data\":{\"package-base64\":\"${PACKAGE_B64}\"}}" > package_payload.json
                vaultBevelFunc 'write' "${PACKAGE_VAULT_ADDR}" 'package_payload.json'
                {{- else }}
                echo "Storing package in Kubernetes secret..."
                kubectl create secret generic ${PACKAGE_NAME}-package \
                  --namespace {{ .Release.Namespace }} \
                  --from-file=package=${PACKAGE_NAME}.tgz \
                  --dry-run=client -o yaml | kubectl apply -f -
                {{- end }}
                
                echo "Package stored successfully"
              else
                echo "Package already exists, skipping creation..."
              fi
              
              # Check if chaincode is already installed
              echo "Checking if chaincode is already installed..."
              PEER_POD=$(kubectl get pods -n {{ .Release.Namespace }} -l app={{ .Values.peer.name }} -o jsonpath='{.items[0].metadata.name}')
              if [ -z "$PEER_POD" ]; then
                echo "Error: Peer pod not found"
                exit 1
              fi
              
              # Check installed chaincodes
              INSTALLED_CC=$(kubectl exec -n {{ .Release.Namespace }} $PEER_POD -c {{ .Values.peer.name }} -- \
                peer lifecycle chaincode queryinstalled -O json | \
                jq -r --arg label "${PACKAGE_NAME}" '.installed_chaincodes[]? | select(.label==$label) | .package_id' || echo "")
              
              if [ -n "$INSTALLED_CC" ]; then
                echo "Chaincode ${PACKAGE_NAME} is already installed with package ID: $INSTALLED_CC"
              else
                echo "Installing chaincode package..."
                
                # Get the package from storage and install
                {{- if eq .Values.global.vault.type "hashicorp" }}
                # Get package from vault
                vaultBevelFunc 'readJson' "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/chaincodes/${CHAINCODE_NAME}/package/v${CHAINCODE_VERSION}"
                if [ "$SECRETS_AVAILABLE" = "yes" ]; then
                  echo "${VAULT_SECRET}" | jq -r ".\"package-base64\"" | base64 -d > /tmp/${PACKAGE_NAME}.tgz
                else
                  echo "Error: Package not found in vault"
                  exit 1
                fi
                {{- else }}
                # Get package from Kubernetes secret
                kubectl get secret --namespace {{ .Release.Namespace }} ${PACKAGE_NAME}-package -o jsonpath='{.data.package}' | base64 -d > /tmp/${PACKAGE_NAME}.tgz
                {{- end }}
                
                # Copy package to peer pod and install
                kubectl cp /tmp/${PACKAGE_NAME}.tgz {{ .Release.Namespace }}/$PEER_POD:/opt/gopath/src/github.com/hyperledger/fabric/${PACKAGE_NAME}.tgz -c {{ .Values.peer.name }}
                
                # Install the chaincode
                kubectl exec -n {{ .Release.Namespace }} $PEER_POD -c {{ .Values.peer.name }} -- \
                  peer lifecycle chaincode install ${PACKAGE_NAME}.tgz
                
                # Verify installation
                INSTALLED_CC=$(kubectl exec -n {{ .Release.Namespace }} $PEER_POD -c {{ .Values.peer.name }} -- \
                  peer lifecycle chaincode queryinstalled -O json | \
                  jq -r --arg label "${PACKAGE_NAME}" '.installed_chaincodes[]? | select(.label==$label) | .package_id')
                
                if [ -n "$INSTALLED_CC" ]; then
                  echo "Chaincode installed successfully with package ID: $INSTALLED_CC"
                  
                  # Store the package ID for future reference
                  {{- if eq .Values.global.vault.type "hashicorp" }}
                  echo "{\"data\":{\"package_id\":\"${INSTALLED_CC}\"}}" > package_id_payload.json
                  vaultBevelFunc 'write' "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/chaincodes/${CHAINCODE_NAME}/package_id/v${CHAINCODE_VERSION}" 'package_id_payload.json'
                  {{- else }}
                  kubectl create secret generic ${PACKAGE_NAME}-package-id \
                    --namespace {{ .Release.Namespace }} \
                    --from-literal=package_id="${INSTALLED_CC}" \
                    --dry-run=client -o yaml | kubectl apply -f -
                  {{- end }}
                else
                  echo "Error: Chaincode installation failed"
                  exit 1
                fi
              fi
              
              echo "Chaincode package and installation completed successfully"
          volumeMounts:
          - name: certificates
            mountPath: /crypto-config
          - name: package-temp
            mountPath: /package-temp
          - name: scripts-volume
            mountPath: /scripts/bevel-vault.sh
            subPath: bevel-vault.sh
          - name: package-manager
            mountPath: /scripts/package-manager.sh
            subPath: package-manager.sh
          {{- if .Values.global.vault.tls }}
          - name: vaultca
            mountPath: /opt/vault/tls
          {{- end }}
