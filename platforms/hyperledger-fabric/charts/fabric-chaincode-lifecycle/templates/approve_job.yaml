##############################################################################################
#  Copyright Sownak Roy. All Rights Reserved.
#  SPDX-License-Identifier: Apache-2.0
##############################################################################################
{{- if .Values.lifecycle.approve.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Release.Name }}-approve
  namespace: {{ .Release.Namespace }}
  labels:
    app: {{ .Release.Name }}-approve
    app.kubernetes.io/name: {{ include "fabric-chaincode-lifecycle.name" . }}-approve
    app.kubernetes.io/component: approve
    app.kubernetes.io/part-of: {{ include "fabric-chaincode-lifecycle.fullname" . }}
    app.kubernetes.io/namespace: {{ .Release.Namespace }}
    app.kubernetes.io/release: {{ .Release.Name }}
    {{- include "labels.custom" . | nindent 4 }}
  annotations:
    helm.sh/hook-weight: "-5"
    helm.sh/hook: "pre-install,pre-upgrade"
    helm.sh/hook-delete-policy: "before-hook-creation,hook-succeeded"
spec:
  backoffLimit: 6
  template:
    metadata:
      labels:
        app: {{ .Release.Name }}-approve
        app.kubernetes.io/name: {{ include "fabric-chaincode-lifecycle.name" . }}-approve
        app.kubernetes.io/component: approve
        app.kubernetes.io/part-of: {{ include "fabric-chaincode-lifecycle.fullname" . }}
        app.kubernetes.io/namespace: {{ .Release.Namespace }}
        app.kubernetes.io/release: {{ .Release.Name }}
    spec:
      restartPolicy: OnFailure
      serviceAccountName: {{ .Values.global.serviceAccountName }}
      {{- if .Values.image.pullSecret }}
      imagePullSecrets:
        - name: {{ .Values.image.pullSecret }}
      {{- end }}
      volumes:
      {{- if .Values.global.vault.tls }}
      - name: vaultca
        secret:
          secretName: {{ .Values.global.vault.tls }}
          items:
          - key: ca.crt.pem
            path: ca-certificates.crt
      {{- end }}
      - name: certificates
        emptyDir:
          medium: Memory
      {{ if .Values.chaincode.pdc.enabled }}
      - name: pdcconfig
        configMap:
          defaultMode: 420
          name: {{ .Release.Name }}-collections-config
      {{ end }}
      - name: scripts-volume
        configMap:
          name: bevel-vault-script
      - name: orderer-tls-cacert
        configMap:
          name: orderer-tls-cacert
          defaultMode: 0775
          items:
            - key: cacert
              path: orderer.crt
      initContainers:
      - name: certificates-init
        image: {{ .Values.image.alpineutils }}
        imagePullPolicy: IfNotPresent
        env:
        - name: VAULT_ADDR
          value: {{ .Values.global.vault.address }}
        - name: VAULT_SECRET_ENGINE
          value: "{{ .Values.global.vault.secretEngine }}"
        - name: VAULT_SECRET_PREFIX
          value: "{{ .Values.global.vault.secretPrefix }}"
        - name: KUBERNETES_AUTH_PATH
          value: {{ .Values.global.vault.authPath }}
        - name: VAULT_APP_ROLE
          value: {{ .Values.global.vault.role }}
        - name: MOUNT_PATH
          value: /secret
        - name: VAULT_TYPE
          value: "{{ .Values.global.vault.type }}"
        command: ["sh", "-c"]
        args:
        - |-
          #!/usr/bin/env sh
          {{- if eq .Values.global.vault.type "hashicorp" }}
          . /scripts/bevel-vault.sh

          # Calling a function to retrieve the vault token.
          vaultBevelFunc "init"

          # Function to get Admin MSP Secret
          function getAdminMspSecret {
            KEY=$1
            echo "Getting Admin MSP certificates from Vault."
            vaultBevelFunc "readJson" "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/users/${KEY}"
            if [ "$SECRETS_AVAILABLE" == "yes" ]
            then
              ADMINCERT=$(echo ${VAULT_SECRET} | jq -r '.["admincerts"]')
              CACERTS=$(echo ${VAULT_SECRET} | jq -r '.["cacerts"]')
              KEYSTORE=$(echo ${VAULT_SECRET} | jq -r '.["keystore"]')
              SIGNCERTS=$(echo ${VAULT_SECRET} | jq -r '.["signcerts"]')
              TLSCACERTS=$(echo ${VAULT_SECRET} | jq -r '.["tlscacerts"]')

              OUTPUT_PATH="${MOUNT_PATH}/admin/msp"

              echo "${ADMINCERT}" > ${OUTPUT_PATH}/admincerts/admin.crt
              echo "${CACERTS}" > ${OUTPUT_PATH}/cacerts/ca.crt
              echo "${KEYSTORE}" > ${OUTPUT_PATH}/keystore/server.key
              echo "${SIGNCERTS}" > ${OUTPUT_PATH}/signcerts/server.crt
              echo "${TLSCACERTS}" > ${OUTPUT_PATH}/tlscacerts/tlsca.crt
              ADMIN_MSP_SECRET="true"
            else
              ADMIN_MSP_SECRET="false"
            fi
          }
          {{- else }}
          function getAdminMspSecret {
            KEY=$1
            KUBENETES_SECRET=$(kubectl get secret ${KEY} --namespace {{ .Release.Namespace }} -o json)
            if  [ "$KUBENETES_SECRET" = "" ]; then
              ADMIN_MSP_SECRET="false"
            else
              ADMINCERT=$(echo ${KUBENETES_SECRET} | jq -r '.data.admincerts'  | base64 -d)
              CACERTS=$(echo ${KUBENETES_SECRET} | jq -r '.data.cacerts'  | base64 -d)
              KEYSTORE=$(echo ${KUBENETES_SECRET} | jq -r '.data.keystore'  | base64 -d)
              SIGNCERTS=$(echo ${KUBENETES_SECRET} | jq -r '.data.signcerts'  | base64 -d)
              TLSCACERTS=$(echo ${KUBENETES_SECRET} | jq -r '.data.tlscacerts'  | base64 -d)

              echo "${ADMINCERT}" > ${OUTPUT_PATH}/admincerts/admin.crt
              echo "${CACERTS}" > ${OUTPUT_PATH}/cacerts/ca.crt
              echo "${KEYSTORE}" > ${OUTPUT_PATH}/keystore/server.key
              echo "${SIGNCERTS}" > ${OUTPUT_PATH}/signcerts/server.crt
              echo "${TLSCACERTS}" > ${OUTPUT_PATH}/tlscacerts/tlsca.crt   
              ADMIN_MSP_SECRET="true"
            fi            
          }

          {{- end }}
          echo "Getting MSP certificates from Vault."

          OUTPUT_PATH="${MOUNT_PATH}/admin/msp"
          mkdir -p ${OUTPUT_PATH}/admincerts
          mkdir -p ${OUTPUT_PATH}/cacerts
          mkdir -p ${OUTPUT_PATH}/keystore
          mkdir -p ${OUTPUT_PATH}/signcerts
          mkdir -p ${OUTPUT_PATH}/tlscacerts
          COUNTER=1
          while [ "$COUNTER" -le 20 ]
          do
            getAdminMspSecret admin-msp
            if [ "$ADMIN_MSP_SECRET" = "true" ]
            then
              echo "Admin certificates have been obtained correctly"
              break
            else
              echo "Admin certificates have not been obtained, sleeping for 15 seconds"
              sleep 15
              COUNTER=`expr "$COUNTER" + 1`
            fi
          done

          if [ "$COUNTER" -gt 20 ]
          then
            echo "Retry attempted `expr $COUNTER - 1` times, Admin certificates have not been obtained."
            exit 1
          fi

        volumeMounts:
        {{- if .Values.global.vault.tls }}
        - name: vaultca
          mountPath: "/etc/ssl/certs/"
          readOnly: true
        {{- end }}
        - name: certificates
          mountPath: /secret
        - name: scripts-volume
          mountPath: /scripts/bevel-vault.sh
          subPath: bevel-vault.sh
      containers:
      - name: approve-chaincode
        image: {{ .Values.image.fabrictools }}:{{ .Values.global.version }}
        imagePullPolicy: IfNotPresent
        env:
        - name: CORE_VM_ENDPOINT
          value: unix:///host/var/run/docker.sock
        - name: FABRIC_LOGGING_SPEC
          value: "{{ .Values.peer.logLevel }}"
        - name: CORE_PEER_ID
          value: {{ .Values.peer.name }}.{{ .Release.Namespace }}
        - name: CORE_PEER_ADDRESS
          value: {{ .Values.peer.address }}
        - name: CORE_PEER_LOCALMSPID
          value: {{ .Values.peer.localMspId }}
        - name: CORE_PEER_TLS_ENABLED
          value: "{{ .Values.peer.tlsStatus }}"
        - name: CORE_PEER_TLS_ROOTCERT_FILE
          value: "/opt/gopath/src/github.com/hyperledger/fabric/crypto/admin/msp/tlscacerts/tlsca.crt"
        - name: ORDERER_CA
          value: "/opt/gopath/src/github.com/hyperledger/fabric/orderer/tls/orderer.crt"
        - name: CORE_PEER_MSPCONFIGPATH
          value: "/opt/gopath/src/github.com/hyperledger/fabric/crypto/admin/msp"
        - name: ORDERER_URL
          value: {{ .Values.peer.ordererAddress }}
        - name: CHANNEL_NAME
          value: "{{ .Values.chaincode.channel }}"
        - name: CHAINCODE_NAME
          value: "{{ .Values.chaincode.name }}"
        - name: CHAINCODE_VERSION
          value: "{{ .Values.chaincode.version }}"
        - name: CHAINCODE_SEQUENCE
          value: "{{ .Values.chaincode.sequence }}"
        - name: INIT_REQUIRED
          value: "{{ .Values.chaincode.initRequired }}"
        - name: CORE_CHAINCODE_BUILDER
          value: "{{ .Values.chaincode.builder }}"
        - name: ENDORSEMENT_POLICIES
          value: "{{ .Values.chaincode.endorsementPolicies }}"
        - name: PDC_ENABLED
          value: "{{ .Values.chaincode.pdc.enabled }}"
        stdin: true
        tty: true
        command: ["sh", "-c"]
        args:
        - |-
          #!/bin/bash sh
 
          # Set up logging function for better visibility
          log_info() { echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') - $1"; }
          log_error() { echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2; }
          log_success() { echo "[SUCCESS] $(date '+%Y-%m-%d %H:%M:%S') - $1"; }
          
          # Function to execute a command with retries
          execute_with_retry() {
            local cmd="$1"
            local desc="$2"
            local max_attempts=5
            local delay=10
            
            for attempt in $(seq 1 $max_attempts); do
              log_info "Attempt $attempt of $max_attempts: $desc"
              if eval "$cmd"; then
                log_success "$desc completed successfully"
                return 0
              else
                if [ $attempt -lt $max_attempts ]; then
                  log_info "Attempt $attempt failed, retrying in ${delay}s..."
                  sleep $delay
                else
                  log_error "$desc failed after $max_attempts attempts"
                  return 1
                fi
              fi
            done
          }

          log_info "======== Starting chaincode approval process ========"
          {{- if .Values.lifecycle.approve.waitForInstall }}
          # Wait for chaincode installation to be completed
          log_info "Waiting for chaincode installation to complete..."
          max_wait=600
          wait_time=0
          while [ $wait_time -lt $max_wait ]; do
            if peer lifecycle chaincode queryinstalled --output json | jq -r '.installed_chaincodes[] | select(.label=="'${CHAINCODE_NAME}'-'${CHAINCODE_VERSION}'") | .package_id' | grep -q "."; then
              log_success "Chaincode installation detected"
              break
            fi
            log_info "Waiting for chaincode installation... ($wait_time/$max_wait seconds)"
            sleep 10
            wait_time=$((wait_time + 10))
          done
          
          if [ $wait_time -ge $max_wait ]; then
            log_error "Timeout waiting for chaincode installation"
            exit 1
          fi
          {{- end }}

          # Extract package ID
          log_info "Extracting chaincode package ID..."
          PACKAGE_ID=$(peer lifecycle chaincode queryinstalled --output json | jq -r '.installed_chaincodes[] | select(.label=="'${CHAINCODE_NAME}'-'${CHAINCODE_VERSION}'") | .package_id')
          
          if [ -z "$PACKAGE_ID" ]; then
            log_error "Failed to extract package ID for chaincode ${CHAINCODE_NAME}-${CHAINCODE_VERSION}"
            exit 1
          fi
          log_info "Package ID: $PACKAGE_ID"

          # Check if already approved
          log_info "Checking if chaincode is already approved..."
          if peer lifecycle chaincode queryapproved -C ${CHANNEL_NAME} -n ${CHAINCODE_NAME} --sequence ${CHAINCODE_SEQUENCE} >/dev/null 2>&1; then
            log_info "Chaincode ${CHAINCODE_NAME} v${CHAINCODE_VERSION} is already approved"
            exit 0
          fi

          # Build approve command
          APPROVE_CMD="peer lifecycle chaincode approveformyorg -o ${ORDERER_URL} --tls ${CORE_PEER_TLS_ENABLED} --cafile ${ORDERER_CA} --channelID ${CHANNEL_NAME} --name ${CHAINCODE_NAME} --version ${CHAINCODE_VERSION} --package-id ${PACKAGE_ID} --sequence ${CHAINCODE_SEQUENCE}"
          
          if [ "${INIT_REQUIRED}" = "true" ]; then
            APPROVE_CMD="${APPROVE_CMD} --init-required"
          fi

          # Handle Private Data Collections
          if [ "${PDC_ENABLED}" = "true" ]; then
            log_info "PDC is enabled.  private data collections configuration"
            APPROVE_CMD="${APPROVE_CMD} --collections-config /opt/pdc/collections_config.json"
          fi

          if [ -n ${ENDORSEMENT_POLICIES} ]; then
            log_info "Adding endorsement policy: ${ENDORSEMENT_POLICIES}"
            # Write the policy to a temporary file to avoid shell escaping issues
            echo "${ENDORSEMENT_POLICIES}" > /tmp/endorsement_policy.txt
            POLICY_FROM_FILE=$(cat /tmp/endorsement_policy.txt)
            APPROVE_CMD="${APPROVE_CMD} --signature-policy"
            APPROVE_CMD="${APPROVE_CMD} \"${POLICY_FROM_FILE}\""
          fi

          log_info "Final approve command: ${APPROVE_CMD}"

          execute_with_retry "${APPROVE_CMD}" "Approve chaincode" 
          log_success "Chaincode approval completed successfully!"
          log_success "Channel: ${CHANNEL_NAME}"
          log_success "Chaincode: ${CHAINCODE_NAME}"
          log_success "Version: ${CHAINCODE_VERSION}"
          log_success "Sequence: ${CHAINCODE_SEQUENCE}"
          log_info "======== Chaincode approval process complete ========"
        volumeMounts:
        - name: certificates
          mountPath: /opt/gopath/src/github.com/hyperledger/fabric/crypto
          readOnly: true
        - name: orderer-tls-cacert
          mountPath: /opt/gopath/src/github.com/hyperledger/fabric/orderer/tls/orderer.crt
          subPath: orderer.crt
        {{ if .Values.chaincode.pdc.enabled }}
        - name: pdcconfig
          mountPath: /opt/pdc
        {{ end }}
{{- end }}
